const kTooltipConfig = {
    align: "left",
    font: {
        family: "Courier New, monospace",
        size: 14
    }
};

document.addEventListener("DOMContentLoaded", function () {
    const allRawData = {{ results_data | tojson | safe }};

    const comparisonSchemes = {
        "by-cpu": {field: "cpu_manufacturer", title: "CPU"},
        "by-gpu": {field: "gpu_renderer", title: "GPU"},
        "by-gpu-vendor": {field: "gpu_vendor", title: "GPU Vendor"},
        "by-os": {field: "os_system", title: "Operating System"},
        "by-renderer": {field: "renderer", title: "Renderer Backend"},
        "by-version": {field: "xemu_version", title: "xemu Version"},
    };

    const chartsContainer = document.getElementById("charts-container");
    const selector = document.getElementById("slice-selector");
    const outlierCheckbox = document.getElementById("outlier-checkbox");

    for (const key in comparisonSchemes) {
        const option = document.createElement("option");
        option.value = key;
        option.textContent = comparisonSchemes[key].title;
        selector.appendChild(option);
    }

    const savedMode = localStorage.getItem("xemuPerfChartMode");
    const savedOutlier = localStorage.getItem("xemuPerfExcludeOutlier");

    if (savedMode && comparisonSchemes[savedMode]) {
        selector.value = savedMode;
    } else {
        selector.value = "by-version";
    }
    if (savedOutlier) {
        outlierCheckbox.checked = (savedOutlier === "true");
    } else {
        outlierCheckbox.checked = true;
    }

    const responsiveChartConfig = {responsive: true};

    function shortVersion(xemu_version) {
        {#  xemu-0.8.92-master-<githash> #}
        {#  xemu-0.8.92-<build>-g<shorthash>-<branch_name>-<githash> #}

        match = xemu_version.match(/xemu-([0-9]+.[0-9]+.[0-9]+)-([0-9]+)-g.+-(.+)-.+/);
        if (match && match[1]) {
            return `${match[1]}-${match[2]}-${match[3]}`;
        }

        match = xemu_version.match(/xemu-([0-9]+.[0-9]+.[0-9]+)-master-.*/);
        if (match && match[1]) {
            return `${match[1]}`;
        }

        return xemu_version;
    }

    function renderSummaryChart(scheme, processedData) {
        const summaryChartDiv = document.createElement("div");
        summaryChartDiv.className = "chart-container";
        chartsContainer.appendChild(summaryChartDiv);

        const means = {};
        for (const d of processedData) {
            const category = d[scheme.field];
            if (!means[category]) {
                means[category] = {total_us: 0, count: 0};
            }
            means[category].total_us += d.average_us;
            means[category].count++;
        }

        const summaryData = Object.entries(means).map(([category, totals]) => {
            const displayCategory = (scheme.field === "xemu_version") ? shortVersion(category) : category;
            return {
                category: displayCategory,
                score: (totals.total_us / totals.count) / 1000.0,
                points: totals.count
            };
        });

        const trace = {
            type: "bar",
            x: summaryData.map(d => d.category),
            y: summaryData.map(d => d.score),
            customdata: summaryData.map(d => d.points),
            hovertemplate: "<b>%{y}</b><br>" +
                "Num data points: %{customdata}" +
                "<extra></extra>"
        };

        const layout = {
            title: {
                text: "Overall duration (lower is better)",
                font: {
                    family: "Arial",
                    size: 22
                },
                x: 0.5,
                xanchor: 'center'
            },
            xaxis: {
                title: scheme.title,
                automargin: true,
                tickangle: -25
            },
            yaxis: {title: "Sum of averages"},
            hoverlabel: kTooltipConfig
        };

        Plotly.newPlot(summaryChartDiv, [trace], layout, responsiveChartConfig);
    }

    function renderTestResultCharts(selectedSchemeKey, scheme, processedData) {
        const testsByName = processedData.reduce((acc, d) => {
            (acc[d.test_name] = acc[d.test_name] || []).push(d);
            return acc;
        }, {});

        for (const testName in testsByName) {
            const chartDiv = document.createElement("div");
            chartDiv.className = "chart-container";
            chartsContainer.appendChild(chartDiv);

            const testData = testsByName[testName];

            let traces;
            let layout;

            if (selectedSchemeKey === "by-version") {
                traces = [{
                    type: "scatter",
                    mode: "markers",
                    x: testData.map(d => shortVersion(d[scheme.field])),
                    y: testData.map(d => d.average_ms),
                    transforms: [{
                        type: "groupby",
                        groups: testData.map(d => d[scheme.field])
                    }],
                    customdata: testData.map(d => [
                        d.xemu_version, d.os_system, d.cpu_manufacturer, d.gpu_renderer, d.renderer
                    ]),
                    hovertemplate: "<b>%{y:.2f} ms</b><br>" +
                        "Xemu    %{customdata[0]}<br>" +
                        "OS      %{customdata[1]}<br>" +
                        "CPU     %{customdata[2]}<br>" +
                        "GPU     %{customdata[3]}<br>" +
                        "Backend %{customdata[4]}<br>" +
                        "<extra></extra>"
                }];

                layout = {
                    title: {
                        text: `${testName} by ${scheme.title}`,
                        font: {
                            family: "Arial",
                            size: 22
                        },
                        x: 0.5,
                        xanchor: 'center'
                    },
                    xaxis: {
                        title: scheme.title,
                        automargin: true,
                        tickangle: -25
                    },
                    yaxis: {title: "Avg duration (ms)", autorange: true},
                    showlegend: false,
                    hoverlabel: kTooltipConfig
                };

            } else {
                traces = [];
                const versions = testData.reduce((acc, d) => {
                    (acc[d.xemu_version] = acc[d.xemu_version] || []).push(d);
                    return acc;
                }, {});

                for (const version in versions) {
                    const versionData = versions[version];
                    traces.push({
                        type: "scatter",
                        mode: "markers",
                        name: shortVersion(version),
                        x: versionData.map(d => d[scheme.field]),
                        y: versionData.map(d => d.average_ms),
                        customdata: versionData.map(d => [
                            d.xemu_version, d.os_system, d.cpu_manufacturer, d.gpu_renderer, d.renderer
                        ]),
                        hovertemplate: "<b>%{y:.2f} ms</b><br>" +
                            "Xemu    %{customdata[0]}<br>" +
                            "OS      %{customdata[1]}<br>" +
                            "CPU     %{customdata[2]}<br>" +
                            "GPU     %{customdata[3]}<br>" +
                            "Backend %{customdata[4]}<br>" +
                            "<extra></extra>"
                    });
                }

                layout = {
                    title: {
                        text: `${testName} by ${scheme.title}`,
                        font: {
                            family: "Arial",
                            size: 22
                        },
                        x: 0.5,
                        xanchor: 'center'
                    },
                    xaxis: {
                        title: scheme.title,
                        automargin: true,
                        tickangle: -25
                    },
                    yaxis: {title: "Avg duration (ms)", autorange: true},
                    showlegend: true,
                    hoverlabel: kTooltipConfig,
                    margin: {t: 50}
                };
            }

            Plotly.newPlot(chartDiv, traces, layout, responsiveChartConfig);
        }
    }

    function renderAllCharts() {
        const excludeOutliers = outlierCheckbox.checked;
        const selectedSchemeKey = selector.value;
        const scheme = comparisonSchemes[selectedSchemeKey];
        chartsContainer.innerHTML = "";

        localStorage.setItem("xemuPerfChartMode", selectedSchemeKey);
        localStorage.setItem("xemuPerfExcludeOutlier", excludeOutliers);

        if (!allRawData || allRawData.length === 0) {
            chartsContainer.innerHTML = "<p>No data available to display.</p>";
            return;
        }

        const processedData = allRawData.map(d => {
            if (excludeOutliers && d.iterations > 1) {
                const newAverage = (d.total_us - d.max_us) / (d.iterations - 1);
                return {
                    ...d,
                    average_us: newAverage,
                    average_ms: newAverage / 1000.0
                };
            }
            return {
                ...d,
                average_ms: d.average_us / 1000.0
            };
        });

        renderSummaryChart(scheme, processedData);
        renderTestResultCharts(selectedSchemeKey, scheme, processedData);
    }

    selector.addEventListener("change", renderAllCharts);
    outlierCheckbox.addEventListener("change", renderAllCharts);
    renderAllCharts();
});