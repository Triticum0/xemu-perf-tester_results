const kTooltipConfig = {
    align: "left",
    font: {
        family: "Courier New, monospace",
        size: 14
    }
};

const kCommonXAxisConfig = {
    automargin: true,
    tickangle: -25,
    categoryorder: "category ascending"
};

const kCommonMarkerConfig = {
    size: 10
};

const kSearchableDataFields = [
    "cpu_manufacturer",
    "gpu_renderer",
    "gpu_vendor",
    "os_system",
    "renderer",
    "xemu_version",
    "machine_info"
];

const kDebounceTimeoutMilliseconds = 100;

const kMatchingDataItemsPadding = 20;

document.addEventListener("DOMContentLoaded", function () {
    let debounceTimer;
    const allRawData = {{ results_data | tojson | safe }};

    const chartsContainer = document.getElementById("charts-container");
    const selector = document.getElementById("slice-selector");
    const outlierCheckbox = document.getElementById("outlier-checkbox");

    const fullscreenOverlay = document.getElementById("fullscreen-overlay");
    const fullscreenChartDiv = document.getElementById("fullscreen-chart");
    const closeFullscreenBtn = document.getElementById("close-fullscreen");

    closeFullscreenBtn.addEventListener("click", () => {
        fullscreenOverlay.style.display = "none";
        Plotly.purge(fullscreenChartDiv);
    });

    const testFilterInput = document.getElementById("test-filter");
    const dataFilterInput = document.getElementById("data-filter");

    const suggestionsOverlay = document.getElementById("data-filter-suggestions");

    const comparisonSchemes = {
        "by-cpu": {field: "cpu_manufacturer", title: "CPU"},
        "by-gpu": {field: "gpu_renderer", title: "GPU"},
        "by-gpu-vendor": {field: "gpu_vendor", title: "GPU Vendor"},
        "by-os": {field: "os_system", title: "Operating System"},
        "by-renderer": {field: "renderer", title: "Renderer Backend"},
        "by-version": {field: "xemu_version", title: "xemu Version"},
    };

    for (const key in comparisonSchemes) {
        const option = document.createElement("option");
        option.value = key;
        option.textContent = comparisonSchemes[key].title;
        selector.appendChild(option);
    }

    const savedMode = localStorage.getItem("xemuPerfChartMode");
    const savedOutlier = localStorage.getItem("xemuPerfExcludeOutlier");

    if (savedMode && comparisonSchemes[savedMode]) {
        selector.value = savedMode;
    } else {
        selector.value = "by-version";
    }
    if (savedOutlier) {
        outlierCheckbox.checked = (savedOutlier === "true");
    } else {
        outlierCheckbox.checked = true;
    }

    const responsiveChartConfig = {responsive: true};

    function shortVersion(xemu_version) {
        {#  xemu-0.8.92-master-<githash> #}
        {#  xemu-0.8.92-<build>-g<shorthash>-<branch_name>-<githash> #}

        match = xemu_version.match(/xemu-([0-9]+.[0-9]+.[0-9]+)-([0-9]+)-g.+-(.+)-.+/);
        if (match && match[1]) {
            return `${match[1]}-${match[2]}-${match[3]}`;
        }

        match = xemu_version.match(/xemu-([0-9]+.[0-9]+.[0-9]+)-master-.*/);
        if (match && match[1]) {
            return `${match[1]}`;
        }

        return xemu_version;
    }

    function renderSummaryChart(scheme, processedData) {
        const summaryChartDiv = document.createElement("div");
        summaryChartDiv.className = "chart-container";
        summaryChartDiv.dataset.testName = "summary-chart";
        chartsContainer.appendChild(summaryChartDiv);

        const means = {};
        for (const d of processedData) {
            const category = d[scheme.field];
            if (!means[category]) {
                means[category] = {total_us: 0, count: 0};
            }
            means[category].total_us += d.average_us;
            means[category].count++;
        }

        const summaryData = Object.entries(means).map(([category, totals]) => {
            const displayCategory = (scheme.field === "xemu_version") ? shortVersion(category) : category;
            return {
                category: displayCategory,
                score: (totals.total_us / totals.count) / 1000.0,
                points: totals.count
            };
        });

        const trace = {
            type: "bar",
            x: summaryData.map(d => d.category),
            y: summaryData.map(d => d.score),
            customdata: summaryData.map(d => d.points),
            hovertemplate: "<b>%{y}</b><br>" +
                "Num data points: %{customdata}" +
                "<extra></extra>"
        };

        const layout = {
            title: {
                text: "Overall average duration (lower is better)",
                font: {
                    family: "Arial",
                    size: 22
                },
                x: 0.5,
                xanchor: "center"
            },
            xaxis: {
                ...kCommonXAxisConfig,
                title: scheme.title,
            },
            yaxis: {title: "Sum of averages"},
            hoverlabel: kTooltipConfig
        };
        Plotly.newPlot(summaryChartDiv, [trace], layout, responsiveChartConfig);

        const expandButton = document.createElement("button");
        expandButton.textContent = "Expand";
        expandButton.className = "expand-button";
        summaryChartDiv.appendChild(expandButton);

        expandButton.addEventListener("click", () => {
            const fullscreenLayout = JSON.parse(JSON.stringify(layout));
            fullscreenLayout.title.font = {size: 24};
            fullscreenOverlay.style.display = "block";
            Plotly.newPlot(fullscreenChartDiv, [trace], fullscreenLayout, {responsive: true});
        });
    }

    function symbolForRendererBackend(renderer_backend) {
        if (renderer_backend === "GL") {
            return "circle";
        }

        if (renderer_backend === "VK") {
            return "star-open-dot";
        }

        return "x";
    }

    function filteredTestsByName(processedData, filterText) {
        let testsByName = processedData.reduce((acc, d) => {
            (acc[d.test_name] = acc[d.test_name] || []).push(d);
            return acc;
        }, {});

        if (!filterText) {
            return testsByName;
        }

        const filteredTests = {};
        for (const testName in testsByName) {
            if (testName.toLowerCase().includes(filterText)) {
                filteredTests[testName] = testsByName[testName];
            }
        }
        return filteredTests;
    }

    function onPointClick(chart, points, selectedSchemeKey, scheme, testData) {
        if (!points.length) {
            return;
        }

        const clickedPoint = points[0];
        const machine_id_with_renderer = clickedPoint.customdata[6];

        if (!machine_id_with_renderer) {
            return;
        }

        const machineData = testData
            .filter(d => d.machine_id_with_renderer === machine_id_with_renderer)
            .sort((a, b) => {
                const valA = (selectedSchemeKey === "by-version") ? shortVersion(a[scheme.field]) : a[scheme.field];
                const valB = (selectedSchemeKey === "by-version") ? shortVersion(b[scheme.field]) : b[scheme.field];
                if (typeof valA === "string") {
                    return valA.localeCompare(valB);
                }
                return valA - valB;
            });

        const lineTrace = {
            type: "scatter",
            mode: "lines",
            x: machineData.map(d => (selectedSchemeKey === "by-version") ? shortVersion(d[scheme.field]) : d[scheme.field]),
            y: machineData.map(d => d.average_ms),
            line: {
                color: "rgba(60, 20, 60, 0.7)",
                width: 2
            },
            hoverinfo: "none",
            showlegend: false,
            name: "connection_line"
        };

        const tracesToRemove = [];
        chart.data.forEach((trace, index) => {
            if (trace.name === "connection_line") {
                tracesToRemove.push(index);
            }
        });

        if (tracesToRemove.length > 0) {
            Plotly.deleteTraces(chart, tracesToRemove);
        }

        Plotly.addTraces(chart, lineTrace);
    }

    function renderTestResultCharts(selectedSchemeKey, scheme, processedData, filterText) {
        const testsByName = filteredTestsByName(processedData, filterText)

        for (const testName in testsByName) {
            const chartDiv = document.createElement("div");
            chartDiv.className = "chart-container";
            chartDiv.dataset.testName = testName;
            chartsContainer.appendChild(chartDiv);

            const testData = testsByName[testName];

            let traces;
            let layout;

            if (selectedSchemeKey === "by-version") {
                traces = [{
                    type: "scatter",
                    mode: "markers",
                    marker: {
                        ...kCommonMarkerConfig,
                        symbol: testData.map(d => symbolForRendererBackend(d.renderer))
                    },
                    x: testData.map(d => shortVersion(d[scheme.field])),
                    y: testData.map(d => d.average_ms),
                    transforms: [{
                        type: "groupby",
                        groups: testData.map(d => d[scheme.field])
                    }],
                    customdata: testData.map(d => [
                        d.xemu_version,
                        d.os_system,
                        d.cpu_manufacturer,
                        d.gpu_renderer,
                        d.renderer,
                        d.machine_id,
                        d.machine_id_with_renderer
                    ]),
                    hovertemplate: "<b>%{y:.2f} ms</b><br>" +
                        "Xemu    %{customdata[0]}<br>" +
                        "OS      %{customdata[1]}<br>" +
                        "CPU     %{customdata[2]}<br>" +
                        "GPU     %{customdata[3]}<br>" +
                        "Backend %{customdata[4]}<br>" +
                        "<extra></extra>"
                }];

                layout = {
                    title: {
                        text: `${testName} by ${scheme.title}`,
                        font: {
                            family: "Arial",
                            size: 22
                        },
                        x: 0.5,
                        xanchor: "center"
                    },
                    xaxis: {
                        ...kCommonXAxisConfig,
                        title: scheme.title,
                    },
                    yaxis: {title: "Avg duration (ms)", autorange: true},
                    showlegend: false,
                    hoverlabel: kTooltipConfig
                };

            } else {
                traces = [];
                const versions = testData.reduce((acc, d) => {
                    (acc[d.xemu_version] = acc[d.xemu_version] || []).push(d);
                    return acc;
                }, {});

                for (const version in versions) {
                    const versionData = versions[version];
                    traces.push({
                        type: "scatter",
                        mode: "markers",
                        name: shortVersion(version),
                        marker: {
                            ...kCommonMarkerConfig,
                            symbol: versionData.map(d => symbolForRendererBackend(d.renderer))
                        },
                        x: versionData.map(d => d[scheme.field]),
                        y: versionData.map(d => d.average_ms),
                        customdata: versionData.map(d => [
                            d.xemu_version,
                            d.os_system,
                            d.cpu_manufacturer,
                            d.gpu_renderer,
                            d.renderer,
                            d.machine_id,
                            d.machine_id_with_renderer
                        ]),
                        hovertemplate: "<b>%{y:.2f} ms</b><br>" +
                            "Xemu    %{customdata[0]}<br>" +
                            "OS      %{customdata[1]}<br>" +
                            "CPU     %{customdata[2]}<br>" +
                            "GPU     %{customdata[3]}<br>" +
                            "Backend %{customdata[4]}<br>" +
                            "<extra></extra>"
                    });
                }

                layout = {
                    title: {
                        text: `${testName} by ${scheme.title}`,
                        font: {
                            family: "Arial",
                            size: 22
                        },
                        x: 0.5,
                        xanchor: "center"
                    },
                    xaxis: {
                        ...kCommonXAxisConfig,
                        title: scheme.title,
                    },
                    yaxis: {title: "Avg duration (ms)", autorange: true},
                    showlegend: true,
                    hoverlabel: kTooltipConfig,
                    margin: {t: 50}
                };
            }
            Plotly.newPlot(chartDiv, traces, layout, responsiveChartConfig);

            const expandButton = document.createElement("button");
            expandButton.textContent = "Expand";
            expandButton.className = "expand-button";
            chartDiv.appendChild(expandButton);

            expandButton.addEventListener("click", () => {
                const fullscreenLayout = JSON.parse(JSON.stringify(layout));
                if (fullscreenLayout.title) {
                    fullscreenLayout.title.font = {size: 24};
                }
                fullscreenOverlay.style.display = "block";
                Plotly.newPlot(fullscreenChartDiv, traces, fullscreenLayout, {responsive: true});
            });

            chartDiv.on("plotly_click", function (eventData) {
                onPointClick(chartDiv, eventData.points, selectedSchemeKey, scheme, testData);
            });
        }
    }

    function renderAllCharts() {
        const excludeOutliers = outlierCheckbox.checked;
        const selectedSchemeKey = selector.value;
        const scheme = comparisonSchemes[selectedSchemeKey];
        const testFilterText = testFilterInput.value.toLowerCase().trim();
        const dataFilterText = dataFilterInput.value.toLowerCase().trim();

        localStorage.setItem("xemuPerfChartMode", selectedSchemeKey);
        localStorage.setItem("xemuPerfExcludeOutlier", excludeOutliers);

        chartsContainer.innerHTML = "";

        let filteredRawData = allRawData;
        if (filteredRawData && dataFilterText) {
            filteredRawData = allRawData.filter(d => {
                const searchableString = [
                    d.cpu_manufacturer,
                    d.gpu_renderer,
                    d.gpu_vendor,
                    d.os_system,
                    d.renderer,
                    d.xemu_version,
                    d.machine_info
                ].join(" ").toLowerCase();
                return searchableString.includes(dataFilterText);
            });
        }
        if (!filteredRawData || filteredRawData.length === 0) {
            chartsContainer.innerHTML = "<p>No data available to display.</p>";
            return;
        }

        const processedData = filteredRawData.map(d => {
            if (excludeOutliers && d.iterations > 1) {
                const newAverage = (d.total_us - d.max_us) / (d.iterations - 1);
                return {
                    ...d,
                    average_us: newAverage,
                    average_ms: newAverage / 1000.0
                };
            }
            return {
                ...d,
                average_ms: d.average_us / 1000.0
            };
        });

        if (!testFilterText && !dataFilterText) {
            renderSummaryChart(scheme, processedData);
        }
        renderTestResultCharts(selectedSchemeKey, scheme, processedData, testFilterText);
    }

    function highlightMatch(fullText, filterText) {
        if (!filterText) {
            return fullText;
        }
        const regex = new RegExp(filterText, "gi");

        const result = [];
        let lastIndex = 0;
        let match;
        while ((match = regex.exec(fullText)) !== null) {
            if (match.index > lastIndex) {
                result.push(`<span class="data-filter-suggestion-non-matching-text">${fullText.substring(lastIndex, match.index)}</span>`);
            }
            result.push(`<span class="data-filter-suggestion-matching-text"><u><b>${match[0]}</b></u></span>`);
            lastIndex = regex.lastIndex;
        }

        if (lastIndex < fullText.length) {
            result.push(`<span class="data-filter-suggestion-non-matching-text">${fullText.substring(lastIndex)}</span>`);
        }

        return result.join("");
    }

    function updateFilterSuggestions() {
        const filterText = dataFilterInput.value.toLowerCase().trim();

        if (!filterText) {
            suggestionsOverlay.style.display = "none";
            return;
        }

        const inputContainer = document.getElementById("data-filter-container");
        if (inputContainer) {
            const calculatedMaxWidth = window.innerWidth - kMatchingDataItemsPadding;
            suggestionsOverlay.style.maxWidth = `${calculatedMaxWidth}px`;
        }

        const matchCounts = {};
        let matchingMachines = new Set();
        allRawData.forEach(d => {
            for (const field of kSearchableDataFields) {
                const value = d[field];
                if (value && value.toLowerCase().includes(filterText)) {
                    matchCounts[value] = (matchCounts[value] || new Set()).add(d.machine_id);
                    matchingMachines.add(d.machine_id);
                }
            }
        });

        if (Object.keys(matchCounts).length === 0) {
            suggestionsOverlay.style.display = "none";
            return;
        }

        let html = `<ul>`;
        const sortedMatches = Object.entries(matchCounts).sort();
        for (const [match, matches] of sortedMatches) {
            const highlightedMatch = highlightMatch(match, filterText);
            html += `<li>${highlightedMatch} (${matches.size})</li>`;
        }
        html += "</ul>";

        suggestionsOverlay.innerHTML = html;
        suggestionsOverlay.style.display = "block";
    }

    function handleFilterChange() {
        let anchorTestName = null;
        let previousTopOffset = null;
        const allCurrentCharts = Array.from(document.querySelectorAll(".chart-container"));
        const orderedTestNames = allCurrentCharts.map(c => c.dataset.testName);

        for (const chart of allCurrentCharts) {
            const topPos = chart.getBoundingClientRect().top;
            if (topPos >= 0) {
                anchorTestName = chart.dataset.testName;
                previousTopOffset = topPos;
                break;
            }
        }
        if (!anchorTestName && allCurrentCharts.length > 0) {
            anchorTestName = allCurrentCharts[allCurrentCharts.length - 1].dataset.testName;
        }

        renderAllCharts();

        requestAnimationFrame(() => {
            let targetChart = document.querySelector(`[data-test-name="${anchorTestName}"]`);
            if (!targetChart) {
                const originalIndex = orderedTestNames.indexOf(anchorTestName);
                for (let i = originalIndex - 1; i >= 0; i--) {
                    const previousTestName = orderedTestNames[i];
                    const previousChart = document.querySelector(`[data-test-name="${previousTestName}"]`);
                    if (previousChart) {
                        targetChart = previousChart;
                        break;
                    }
                }
            }

            if (targetChart) {
                const elementPosition = targetChart.getBoundingClientRect().top;
                const targetPosition = elementPosition - previousTopOffset;

                window.scrollTo({top: targetPosition});
            }
        });
    }

    function handleDebouncedChange() {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
            handleFilterChange();
        }, kDebounceTimeoutMilliseconds);
    }

    selector.addEventListener("change", handleFilterChange);
    outlierCheckbox.addEventListener("change", handleFilterChange);
    testFilterInput.addEventListener("input", handleDebouncedChange);
    dataFilterInput.addEventListener("input", () => {
        updateFilterSuggestions();
        handleDebouncedChange();
    });
    dataFilterInput.addEventListener("focus", updateFilterSuggestions);
    dataFilterInput.addEventListener("blur", () => {
        suggestionsOverlay.style.display = "none";
    });

    renderAllCharts();
});